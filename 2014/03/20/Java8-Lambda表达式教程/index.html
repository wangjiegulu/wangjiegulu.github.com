<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="description" content="Wang Jie&#39;s blog -- TO BE AN ARTIST-ENGINNER">
    <meta name="keyword" content="tiantianbyconan, tiantian.china.2, wangjiegulu, Android, Java, J2EE, Huginn, Geek, Github, Git, Gradle, Maven, Google, iOS, JVM, Activity, View, Javascript, Python, code, developer, programer, tech, technology">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="http://avatars3.githubusercontent.com/u/5423194?s=460&v=4">
    <link rel="alternate" type="application/atom+xml" title="Wang Jie" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        Java8 Lambda表达式教程｜Wang Jie&#39;s Blog|Android|Java|Huginn|Geek|code|developer|programer
        
    </title>

    <link rel="canonical" href="http://blog.wangjiegulu.com/2014/03/20/Java8-Lambda表达式教程/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('//o7bkkhiex.bkt.clouddn.com/lion-blur-bg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Wang Jie
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <!-- <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
								
							
						
                    
                        
                    
                        
							
                        <li>
                            <a href="/categories/">categories</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/tags/">tags</a>
                        </li>
							
						
                    
					
					
						<li>
							<a href="/about">About</a>
						</li>
					
                </ul>
            </div>
        </div> -->


        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    <li>
                        <a href="/archives">Archives</a>
                    </li>
                    <li>
                        <a href="/tags">Tags</a>
                    </li>
                    <li>
                        <a href="/about">About</a>
                    </li>
                </ul>
            </div>
        </div>




    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<head>
<!-- <script type='text/javascript' src='//platform-api.sharethis.com/js/sharethis.js#property=5a72df492fd34b00134b0dc1&product=sop' async='async'></script> -->
<script type='text/javascript' src='//platform-api.sharethis.com/js/sharethis.js#property=5a72df492fd34b00134b0dc1&product=sop' async='async'></script>
</head>

<!--only post-->


<img class="wechat-title-img"
     src="http://otnnps88s.bkt.clouddn.com/image/xingkong.jpg">


<style>
    
    header.intro-header {
        background-image: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)), url('http://otnnps88s.bkt.clouddn.com/image/xingkong.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>Java8 Lambda表达式教程</h1>
                    
                    <span class="meta">
                         作者 Wang Jie
                        <span>
                          日期 2014-03-20
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#java"
                           title="java">java</a>
                        
                        <a class="tag" href="/tags/#java8"
                           title="java8">java8</a>
                        
                        <a class="tag" href="/tags/#lambda"
                           title="lambda">lambda</a>
                        
                    </div>
                    <!-- Sharethis 分享 -->
                    <!-- <div class="sharethis-inline-share-buttons" style="margin-top: 18px; opacity: 0.1;"></div> -->
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            Java8 Lambda表达式教程
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container" 
                 style="word-wrap:break-word;overflow:hidden;">

                <p>转自：<a href="http://blog.csdn.net/ioriogami/article/details/12782141" target="_blank" rel="noopener">http://blog.csdn.net/ioriogami/article/details/12782141</a></p>
<p>&nbsp;</p>
<p><span><strong>1. 什么是&lambda;表达式</strong></span></p>
<p>&lambda;表达式本质上是一个匿名方法。让我们来看下面这个例子：</p>
<p>&nbsp;&nbsp;&nbsp; public int add(int x, int y) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x + y;<br>&nbsp;&nbsp;&nbsp; }</p>
<p>转成&lambda;表达式后是这个样子：<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; (int x, int y) -&gt; x + y;</p>
<p>参数类型也可以省略，Java编译器会根据上下文推断出来：</p>
<p>&nbsp;&nbsp;&nbsp; (x, y) -&gt; x + y; //返回两数之和<br>&nbsp;<br>或者</p>
<p>&nbsp;&nbsp;&nbsp; (x, y) -&gt; { return x + y; } //显式指明返回值</p>
<p>可见&lambda;表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。</p>
<p>下面这个例子里的&lambda;表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：</p>
<p>&nbsp;&nbsp;&nbsp; () -&gt; { System.out.println(“Hello Lambda!”); }</p>
<p>如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：</p>
<p>&nbsp;&nbsp;&nbsp; c -&gt; { return c.size(); }</p>
<p>&nbsp;</p>
<p><span><strong>2. &lambda;表达式的类型（它是Object吗？）</strong></span></p>
<p>&lambda;表达式可以被当做是一个Object（注意措辞）。&lambda;表达式的类型，叫做&ldquo;目标类型（target type）&rdquo;。&lambda;表达式的目标类型是&ldquo;函数接口（functional interface）&rdquo;，这是Java8新引入的概念。它的定义是：一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数接口。一般用@FunctionalInterface标注出来（也可以不标）。举例如下：</p>
<p>&nbsp;&nbsp;&nbsp; @FunctionalInterface<br>&nbsp;&nbsp;&nbsp; public interface Runnable { void run(); }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; public interface Callable&lt;V&gt; { V call() throws Exception; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; public interface ActionListener { void actionPerformed(ActionEvent e); }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; public interface Comparator&lt;T&gt; { int compare(T o1, T o2); boolean equals(Object obj); }</p>
<p>注意最后这个Comparator接口。它里面声明了两个方法，貌似不符合函数接口的定义，但它的确是函数接口。这是因为equals方法是Object的，所有的接口都会声明Object的public方法&mdash;&mdash;虽然大多是隐式的。所以，Comparator显式的声明了equals不影响它依然是个函数接口。</p>
<p>你可以用一个&lambda;表达式为一个函数接口赋值：<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Runnable r1 = () -&gt; {System.out.println(“Hello Lambda!”);};<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>然后再赋值给一个Object：</p>
<p>&nbsp;&nbsp;&nbsp; Object obj = r1;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>但却不能这样干：</p>
<p>&nbsp;&nbsp;&nbsp; Object obj = () -&gt; {System.out.println(“Hello Lambda!”);}; // ERROR! Object is not a functional interface!</p>
<p>必须显式的转型成一个函数接口才可以：</p>
<p>&nbsp;&nbsp;&nbsp; Object o = (Runnable) () -&gt; { System.out.println(“hi”); }; // correct<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>一个&lambda;表达式只有在转型成一个函数接口后才能被当做Object使用。所以下面这句也不能编译：</p>
<p>&nbsp;&nbsp;&nbsp; System.out.println( () -&gt; {} ); //错误! 目标类型不明<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>必须先转型:</p>
<p>&nbsp;&nbsp;&nbsp; System.out.println( (Runnable)() -&gt; {} ); // 正确</p>
<p>假设你自己写了一个函数接口，长的跟Runnable一模一样：</p>
<p>&nbsp;&nbsp;&nbsp; @FunctionalInterface<br>&nbsp;&nbsp;&nbsp; public interface MyRunnable {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void run();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>那么</p>
<p>&nbsp;&nbsp;&nbsp; Runnable r1 =&nbsp;&nbsp;&nbsp; () -&gt; {System.out.println(“Hello Lambda!”);};<br>&nbsp;&nbsp;&nbsp; MyRunnable2 r2 = () -&gt; {System.out.println(“Hello Lambda!”);};</p>
<p>都是正确的写法。这说明一个&lambda;表达式可以有多个目标类型（函数接口），只要函数匹配成功即可。<br>但需注意一个&lambda;表达式必须至少有一个目标类型。</p>
<p>JDK预定义了很多函数接口以避免用户重复定义。最典型的是Function：</p>
<p>&nbsp;&nbsp;&nbsp; @FunctionalInterface<br>&nbsp;&nbsp;&nbsp; public interface Function&lt;T, R&gt; {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R apply(T t);<br>&nbsp;&nbsp;&nbsp; }</p>
<p>这个接口代表一个函数，接受一个T类型的参数，并返回一个R类型的返回值。&nbsp;&nbsp;&nbsp;</p>
<p>另一个预定义函数接口叫做Consumer，跟Function的唯一不同是它没有返回值。</p>
<p>&nbsp;&nbsp;&nbsp; @FunctionalInterface<br>&nbsp;&nbsp;&nbsp; public interface Consumer&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void accept(T t);<br>&nbsp;&nbsp;&nbsp; }</p>
<p>还有一个Predicate，用来判断某项条件是否满足。经常用来进行筛滤操作：<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; @FunctionalInterface<br>&nbsp;&nbsp;&nbsp; public interface Predicate&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean test(T t);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>综上所述，一个&lambda;表达式其实就是定义了一个匿名方法，只不过这个方法必须符合至少一个函数接口。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><span><strong>3. &lambda;表达式的使用</strong></span></p>
<p><span><strong>3.1 &lambda;表达式用在何处</strong></span></p>
<p>&lambda;表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。看下面的例子：</p>
<p>&nbsp;&nbsp;&nbsp; Thread oldSchool = new Thread( new Runnable () {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Override<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void run() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“This is from an anonymous class.”);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; } );<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; Thread gaoDuanDaQiShangDangCi = new Thread( () -&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“This is from an anonymous method (lambda exp).”);<br>&nbsp;&nbsp;&nbsp; } );</p>
<p>注意第二个线程里的&lambda;表达式，你并不需要显式地把它转成一个Runnable，因为Java能根据上下文自动推断出来：一个Thread的构造函数接受一个Runnable参数，而传入的&lambda;表达式正好符合其run()函数，所以Java编译器推断它为Runnable。</p>
<p>从形式上看，&lambda;表达式只是为你节省了几行代码。但将&lambda;表达式引入Java的动机并不仅仅为此。Java8有一个短期目标和一个长期目标。短期目标是：配合&ldquo;集合类批处理操作&rdquo;的内部迭代和并行处理（下面将要讲到）；长期目标是将Java向函数式编程语言这个方向引导（并不是要完全变成一门函数式编程语言，只是让它有更多的函数式编程语言的特性），也正是由于这个原因，Oracle并没有简单地使用内部类去实现&lambda;表达式，而是使用了一种更动态、更灵活、易于将来扩展和改变的策略（invokedynamic）。</p>
<p><span><strong>3.2 &lambda;表达式与集合类批处理操作（或者叫块操作）</strong></span></p>
<p>上文提到了集合类的批处理操作。这是Java8的另一个重要特性，它与&lambda;表达式的配合使用乃是Java8的最主要特性。集合类的批处理操作API的目的是实现集合类的&ldquo;内部迭代&rdquo;，并期望充分利用现代多核CPU进行并行计算。<br>Java8之前集合类的迭代（Iteration）都是外部的，即客户代码。而内部迭代意味着改由Java类库来进行迭代，而不是客户代码。例如：</p>
<p>&nbsp;&nbsp;&nbsp; for(Object o: list) { // 外部迭代<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(o);<br>&nbsp;&nbsp;&nbsp; }</p>
<p>可以写成：</p>
<p>&nbsp;&nbsp;&nbsp; list.forEach(o -&gt; {System.out.println(o);}); //forEach函数实现内部迭代</p>
<p>集合类（包括List）现在都有一个forEach方法，对元素进行迭代（遍历），所以我们不需要再写for循环了。forEach方法接受一个函数接口Consumer做参数，所以可以使用&lambda;表达式。</p>
<p>这种内部迭代方法广泛存在于各种语言，如C++的STL算法库、python、ruby、scala等。</p>
<p>Java8为集合类引入了另一个重要概念：流（stream）。一个流通常以一个集合类实例为其数据源，然后在其上定义各种操作。流的API设计使用了管道（pipelines）模式。对流的一次操作会返回另一个流。如同IO的API或者StringBuffer的append方法那样，从而多个不同的操作可以在一个语句里串起来。看下面的例子：</p>
<p>&nbsp;&nbsp;&nbsp; List&lt;Shape&gt; shapes = …<br>&nbsp;&nbsp;&nbsp; shapes.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .filter(s -&gt; s.getColor() == BLUE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .forEach(s -&gt; s.setColor(RED));</p>
<p>首先调用stream方法，以集合类对象shapes里面的元素为数据源，生成一个流。然后在这个流上调用filter方法，挑出蓝色的，返回另一个流。最后调用forEach方法将这些蓝色的物体喷成红色。（forEach方法不再返回流，而是一个终端方法，类似于StringBuffer在调用若干append之后的那个toString）</p>
<p>filter方法的参数是Predicate类型，forEach方法的参数是Consumer类型，它们都是函数接口，所以可以使用&lambda;表达式。</p>
<p>还有一个方法叫parallelStream()，顾名思义它和stream()一样，只不过指明要并行处理，以期充分利用现代CPU的多核特性。</p>
<p>&nbsp;&nbsp;&nbsp; shapes.parallelStream(); // 或shapes.stream().parallel()</p>
<p>来看更多的例子。下面是典型的大数据处理方法，Filter-Map-Reduce：</p>
<p>&nbsp;&nbsp;&nbsp; //给出一个String类型的数组，找出其中所有不重复的素数<br>&nbsp;&nbsp;&nbsp; public void distinctPrimary(String… numbers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;String&gt; l = Arrays.asList(numbers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;Integer&gt; r = l.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .map(e -&gt; new Integer(e))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .filter(e -&gt; Primes.isPrime(e))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .distinct()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .collect(Collectors.toList());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“distinctPrimary result is: “ + r);<br>&nbsp;&nbsp;&nbsp; }</p>
<p>第一步：传入一系列String（假设都是合法的数字），转成一个List，然后调用stream()方法生成流。</p>
<p>第二步：调用流的map方法把每个元素由String转成Integer，得到一个新的流。map方法接受一个Function类型的参数，上面介绍了，Function是个函数接口，所以这里用&lambda;表达式。</p>
<p>第三步：调用流的filter方法，过滤那些不是素数的数字，并得到一个新流。filter方法接受一个Predicate类型的参数，上面介绍了，Predicate是个函数接口，所以这里用&lambda;表达式。</p>
<p>第四步：调用流的distinct方法，去掉重复，并得到一个新流。这本质上是另一个filter操作。</p>
<p>第五步：用collect方法将最终结果收集到一个List里面去。collect方法接受一个Collector类型的参数，这个参数指明如何收集最终结果。在这个例子中，结果简单地收集到一个List中。我们也可以用Collectors.toMap(e-&gt;e, e-&gt;e)把结果收集到一个Map中，它的意思是：把结果收到一个Map，用这些素数自身既作为键又作为值。toMap方法接受两个Function类型的参数，分别用以生成键和值，Function是个函数接口，所以这里都用&lambda;表达式。</p>
<p>你可能会觉得在这个例子里，List l被迭代了好多次，map，filter，distinct都分别是一次循环，效率会不好。实际并非如此。这些返回另一个Stream的方法都是&ldquo;懒（lazy）&rdquo;的，而最后返回最终结果的collect方法则是&ldquo;急（eager）&rdquo;的。在遇到eager方法之前，lazy的方法不会执行。</p>
<p>当遇到eager方法时，前面的lazy方法才会被依次执行。而且是管道贯通式执行。这意味着每一个元素依次通过这些管道。例如有个元素&ldquo;3&rdquo;，首先它被map成整数型3；然后通过filter，发现是素数，被保留下来；又通过distinct，如果已经有一个3了，那么就直接丢弃，如果还没有则保留。这样，3个操作其实只经过了一次循环。</p>
<p>除collect外其它的eager操作还有forEach，toArray，reduce等。</p>
<p>下面来看一下也许是最常用的收集器方法，groupingBy：</p>
<p>&nbsp;&nbsp;&nbsp; //给出一个String类型的数组，找出其中所有不重复的素数，并统计其出现次数<br>&nbsp;&nbsp;&nbsp; public void primaryOccurrence(String… numbers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;String&gt; l = Arrays.asList(numbers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map&lt;Integer, Integer&gt; r = l.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .map(e -&gt; new Integer(e))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .filter(e -&gt; Primes.isPrime(e))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .collect( Collectors.groupingBy(p-&gt;p, Collectors.summingInt(p-&gt;1)) );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“primaryOccurrence result is: “ + r);<br>&nbsp;&nbsp;&nbsp; }</p>
<p>注意这一行：</p>
<p>&nbsp;&nbsp;&nbsp; Collectors.groupingBy(p-&gt;p, Collectors.summingInt(p-&gt;1))</p>
<p>它的意思是：把结果收集到一个Map中，用统计到的各个素数自身作为键，其出现次数作为值。</p>
<p>下面是一个reduce的例子：</p>
<p>&nbsp;&nbsp;&nbsp; //给出一个String类型的数组，求其中所有不重复素数的和<br>&nbsp;&nbsp;&nbsp; public void distinctPrimarySum(String… numbers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;String&gt; l = Arrays.asList(numbers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sum = l.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .map(e -&gt; new Integer(e))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .filter(e -&gt; Primes.isPrime(e))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .distinct()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .reduce(0, (x,y) -&gt; x+y); // equivalent to .sum()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“distinctPrimarySum result is: “ + sum);<br>&nbsp;&nbsp;&nbsp; }</p>
<p>reduce方法用来产生单一的一个最终结果。<br>流有很多预定义的reduce操作，如sum()，max()，min()等。</p>
<p>再举个现实世界里的栗子比如：</p>
<p>&nbsp;&nbsp;&nbsp; // 统计年龄在25-35岁的男女人数、比例<br>&nbsp;&nbsp;&nbsp; public void boysAndGirls(List&lt;Person&gt; persons) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map&lt;Integer, Integer&gt; result = persons.parallelStream().filter(p -&gt; p.getAge()&gt;=25 &amp;&amp; p.getAge()&lt;=35).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collect(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Collectors.groupingBy(p-&gt;p.getSex(), Collectors.summingInt(p-&gt;1))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(“boysAndGirls result is “ + result);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“, ratio (male : female) is “ + (float)result.get(Person.MALE)/result.get(Person.FEMALE));<br>&nbsp;&nbsp;&nbsp; }</p>
<p><strong><span>3.3 &lambda;表达式的更多用法</span></strong></p>
<p>&nbsp;&nbsp;&nbsp; // 嵌套的&lambda;表达式<br>&nbsp;&nbsp;&nbsp; Callable&lt;Runnable&gt; c1 = () -&gt; () -&gt; { System.out.println(“Nested lambda”); };<br>&nbsp;&nbsp;&nbsp; c1.call().run();</p>
<p>&nbsp;&nbsp;&nbsp; // 用在条件表达式中<br>&nbsp;&nbsp;&nbsp; Callable&lt;Integer&gt; c2 = true ? (() -&gt; 42) : (() -&gt; 24);<br>&nbsp;&nbsp;&nbsp; System.out.println(c2.call());</p>
<p>&nbsp;&nbsp;&nbsp; // 定义一个递归函数<br>&nbsp;&nbsp;&nbsp; private UnaryOperator&lt;Integer&gt; factorial = i -&gt; { return i == 0 ? 1 : i * factorial.apply( i - 1 ); };<br>&nbsp;&nbsp;&nbsp; …<br>&nbsp;&nbsp;&nbsp; System.out.println(factorial.apply(3));</p>
<p>在Java中，随声明随调用的方式是不行的，比如下面这样，声明了一个&lambda;表达式(x, y) -&gt; x + y，同时企图通过传入实参(2, 3)来调用它：</p>
<p>&nbsp;&nbsp;&nbsp; int five = ( (x, y) -&gt; x + y ) (2, 3); // ERROR! try to call a lambda in-place</p>
<p>这在C++中是可以的，但Java中不行。Java的&lambda;表达式只能用作赋值、传参、返回值等。</p>
<p><span><strong>4. 其它相关概念</strong></span></p>
<p><strong><span>4.1 捕获（Capture）</span></strong></p>
<p>捕获的概念在于解决在&lambda;表达式中我们可以使用哪些外部变量（即除了它自己的参数和内部定义的本地变量）的问题。</p>
<p>答案是：与内部类非常相似，但有不同点。不同点在于内部类总是持有一个其外部类对象的引用。而&lambda;表达式呢，除非在它内部用到了其外部类（包围类）对象的方法或者成员，否则它就不持有这个对象的引用。</p>
<p>在Java8以前，如果要在内部类访问外部对象的一个本地变量，那么这个变量必须声明为final才行。在Java8中，这种限制被去掉了，代之以一个新的概念，&ldquo;effectively final&rdquo;。它的意思是你可以声明为final，也可以不声明final但是按照final来用，也就是一次赋值永不改变。换句话说，保证它加上final前缀后不会出编译错误。</p>
<p>在Java8中，内部类和&lambda;表达式都可以访问effectively final的本地变量。&lambda;表达式的例子如下：</p>
<p>&nbsp;&nbsp;&nbsp; …&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int tmp1 = 1; //包围类的成员变量<br>&nbsp;&nbsp;&nbsp; static int tmp2 = 2; //包围类的静态成员变量<br>&nbsp;&nbsp;&nbsp; public void testCapture() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmp3 = 3; //没有声明为final，但是effectively final的本地变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final int tmp4 = 4; //声明为final的本地变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmp5 = 5; //普通本地变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function&lt;Integer, Integer&gt; f1 = i -&gt; i + tmp1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function&lt;Integer, Integer&gt; f2 = i -&gt; i + tmp2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function&lt;Integer, Integer&gt; f3 = i -&gt; i + tmp3;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function&lt;Integer, Integer&gt; f4 = i -&gt; i + tmp4;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function&lt;Integer, Integer&gt; f5 = i -&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp5&nbsp; += i; // 编译错！对tmp5赋值导致它不是effectively final的<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tmp5;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp5 = 9; // 编译错！对tmp5赋值导致它不是effectively final的<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; …</p>
<p>Java要求本地变量final或者effectively final的原因是多线程并发问题。内部类、&lambda;表达式都有可能在不同的线程中执行，允许多个线程同时修改一个本地变量不符合Java的设计理念。</p>
<p><strong><span>4.2 方法引用（Method reference）</span></strong></p>
<p>任何一个&lambda;表达式都可以代表某个函数接口的唯一方法的匿名描述符。我们也可以使用某个类的某个具体方法来代表这个描述符，叫做方法引用。例如：</p>
<p>&nbsp;&nbsp;&nbsp; Integer::parseInt //静态方法引用<br>&nbsp;&nbsp;&nbsp; System.out::print //实例方法引用<br>&nbsp;&nbsp;&nbsp; Person::new&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //构造器引用</p>
<p>下面是一组例子，教你使用方法引用代替&lambda;表达式：</p>
<p>&nbsp;&nbsp;&nbsp; //c1 与 c2 是一样的（静态方法引用）<br>&nbsp;&nbsp;&nbsp; Comparator&lt;Integer&gt; c2 = (x, y) -&gt; Integer.compare(x, y);<br>&nbsp;&nbsp;&nbsp; Comparator&lt;Integer&gt; c1 = Integer::compare;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; //下面两句是一样的（实例方法引用1）<br>&nbsp;&nbsp;&nbsp; persons.forEach(e -&gt; System.out.println(e));<br>&nbsp;&nbsp;&nbsp; persons.forEach(System.out::println);<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; //下面两句是一样的（实例方法引用2）<br>&nbsp;&nbsp;&nbsp; persons.forEach(person -&gt; person.eat());<br>&nbsp;&nbsp;&nbsp; persons.forEach(Person::eat);<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; //下面两句是一样的（构造器引用）<br>&nbsp;&nbsp;&nbsp; strList.stream().map(s -&gt; new Integer(s));<br>&nbsp;&nbsp;&nbsp; strList.stream().map(Integer::new);<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>使用方法引用，你的程序会变得更短些。现在distinctPrimarySum方法可以改写如下：</p>
<p>&nbsp;&nbsp;&nbsp; public void distinctPrimarySum(String… numbers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;String&gt; l = Arrays.asList(numbers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sum = l.stream().map(Integer::new).filter(Primes::isPrime).distinct().sum();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“distinctPrimarySum result is: “ + sum);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>还有一些其它的方法引用:</p>
<p>&nbsp;&nbsp;&nbsp; super::methName //引用某个对象的父类方法<br>&nbsp;&nbsp;&nbsp; TypeName[]::new //引用一个数组的构造器</p>
<p><strong><span>4.3 默认方法（Default method）</span></strong></p>
<p>Java8中，接口声明里可以有方法实现了，叫做默认方法。在此之前，接口里的方法全部是抽象方法。</p>
<p>&nbsp;&nbsp;&nbsp; public interface MyInterf {<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String m1();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default String m2() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return “Hello default method!”;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>这实际上有点混淆接口和抽象类，但一个类仍然可以实现多个接口，而只能继承一个抽象类。</p>
<p>这么做的原因是：由于Collection库需要为批处理操作添加新的方法，如forEach()，stream()等，但是不能修改现有的Collection接口&mdash;&mdash;如果那样做的话所有的实现类都要进行修改，包括很多客户自制的实现类。</p>
<p>那么，我们就面临一种类似多继承的问题。如果类Sub继承了两个接口，Base1和Base2，而这两个接口恰好具有完全相同的两个默认方法，那么就会产生冲突。这时Sub类就必须通过重载来显式指明自己要使用哪一个接口的实现（或者提供自己的实现）：<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; public class Sub implements Base1, Base2 {<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void hello() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Base1.super.hello(); //使用Base1的实现<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; }</p>
<p>除了默认方法，Java8的接口也可以有静态方法的实现：</p>
<p>&nbsp;&nbsp;&nbsp; public interface MyInterf {<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String m1();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default String m2() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return “Hello default method!”;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static String m3() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return “Hello static method in Interface!”;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong><span>4.4 生成器函数（Generator function）</span></strong></p>
<p>有时候一个流的数据源不一定是一个已存在的集合对象，也可能是个&ldquo;生成器函数&rdquo;。一个生成器函数会产生一系列元素，供给一个流。Stream.generate(Supplier&lt;T&gt; s)就是一个生成器函数。其中参数Supplier是一个函数接口，里面有唯一的抽象方法 &lt;T&gt; get()。</p>
<p>下面这个例子生成并打印5个随机数：</p>
<p>&nbsp;&nbsp;&nbsp; Stream.generate(Math::random).limit(5).forEach(System.out::println);</p>
<p>注意这个limit(5)，如果没有这个调用，那么这条语句会永远地执行下去。也就是说这个生成器是无穷的。这种调用叫做终结操作，或者短路（short-circuiting）操作。</p>
<p>&nbsp;</p>
<p><span><strong>参考资料：</strong></span><br><a href="http://openjdk.java.net/projects/lambda/" target="_blank" rel="noopener">http://openjdk.java.net/projects/lambda/</a><br><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a></p>
<p>&nbsp;</p>


                <hr>

                
                <div class="post-copyright" style="margin-top: 20px;">
                    <strong>来源博客：</strong><a href="http://blog.wangjiegulu.com">Wang Jie's Blog</a><br/>
                     <strong>本文链接：</strong><a href="http://blog.wangjiegulu.com/2014/03/20/Java8-Lambda表达式教程/">http://blog.wangjiegulu.com/2014/03/20/Java8-Lambda表达式教程/</a><br/>
                     <strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处。
                </div>
                

                <!-- Sharethis 分享 -->
                <div class="sharethis-inline-share-buttons" style="margin-top: 18px"></div>


                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2014/03/25/Android-AndroidInject增加sqlite3数据库映射注解-ORM/" data-toggle="tooltip" data-placement="top"
                           title="[Android]AndroidInject增加sqlite3数据库映射注解(ORM)">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2014/02/28/Android-异步加载图片，内存缓存，文件缓存，imageview显示图片时增加淡入淡出动画/" data-toggle="tooltip" data-placement="top"
                           title="[Android]异步加载图片，内存缓存，文件缓存，imageview显示图片时增加淡入淡出动画">Next Post &rarr;</a>
                    </li>
                    
                </ul>


                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                


                <!--加入新的评论系统-->
                
            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#java"
                           title="java">java</a>
                        
                        <a class="tag" href="/tags/#java8"
                           title="java8">java8</a>
                        
                        <a class="tag" href="/tags/#lambda"
                           title="lambda">lambda</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="http://www.cnblogs.com/tiantianbyconan/">cnblog</a></li>
                        
                        <li><a href="http://h.wangjiegulu.com">Huginn</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>



<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "blog-wangjiegulu-com";
    var disqus_identifier = "http://blog.wangjiegulu.com/2014/03/20/Java8-Lambda表达式教程/";
    var disqus_url = "http://blog.wangjiegulu.com/2014/03/20/Java8-Lambda表达式教程/";

    (function () {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->





<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://github.com/wangjiegulu">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://instagram.com/wangjiegulu">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://plus.google.com/+%E5%A4%A9%E5%A4%A9wangjie">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://twitter.com/wangjiegulu">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://stackoverflow.com/users/2124006/wangjie">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-stack-overflow fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/wangjiegulu">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/tiantianbyconan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Wang Jie 2018
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv">
                    <br>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://blog.wangjiegulu.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-111189680-2';
    var _gaDomain = 'blog.wangjiegulu.com';
    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>


<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','MeGy6NW2x6vGFz7Hy7SW','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="http://avatars3.githubusercontent.com/u/5423194?s=460&amp;v=4">
</body>

</html>
